# 你不知道的 Node.js 性能优化

## 1、使用最新版本的 Node.js
>最好使用 LTS 版本，长期持续维护


## 2、使用 fast-json-stringify 加速 JSON 序列化

>加速 JSON 序列化,说是比 JSON.stringify 快接近几倍


## 3.有些不赞同, 所以建议  async/await + Promise ,少用 bluebird 

>Promise 是解决回调嵌套地狱的灵丹妙药，特别是当自从 async/await 全面普及之后，
它们的组合无疑成为了 JavaScript 异步编程的终极解决方案，现在大量的项目都已经开始使用这种模式。



- Promise.all() 的并行能力：
```
async function getUserInfo(id) {
    const [profile, repo] = await Promise.all([
        getUserProfile(id),
        getUserRepo(id)
    ])
    return { profile, repo }
}
```


- [fast-async](https://v8.dev/blog/fast-async)


## 5.优化 V8 GC

- 坑一：使用大对象作为缓存，导致老生代（Old Space）的垃圾回收变慢

示例：

```
const cache = {}
async function getUserInfo(id) {
    if (!cache[id]) {
        cache[id] = await getUserInfoFromDatabase(id)
    }
    return cache[id]
}
```

这里我们使用了一个变量 cache 作为缓存，加速用户信息的查询，进行了很多次查询后，  
cache 对象会进入老生代，并且会变得无比庞大，  
而老生代是使用三色标记 + DFS 的方式进行 GC 的，  
一个大对象会直接导致 GC 花费的时间增长（而且也有内存泄漏的风险）。  

解决方法就是：

- 使用 Redis 这样的外部缓存，实际上像 Redis 这样的内存型数据库非常适合这种场景；
- 限制本地缓存对象的大小，比如使用 FIFO、TTL 之类的机制来清理对象中的缓存。


- 坑二：新生代空间不足，导致频繁 GC

这个坑会比较隐蔽。

Node.js 默认给新生代分配的内存是 64MB（64位的机器，后同），  
但因为新生代 GC 使用的是 Scavenge 算法，所以实际能使用的内存只有一半，即 32MB。






## 参考
- [你不知道的Node.js性能优化](https://zhuanlan.zhihu.com/p/50055740)
